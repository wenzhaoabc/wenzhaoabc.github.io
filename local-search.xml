<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>港科广LLM讲座</title>
    <link href="/llm/LLMHKTG/"/>
    <url>/llm/LLMHKTG/</url>
    
    <content type="html"><![CDATA[<h1 id="港科广LLM讲座"><a href="#港科广LLM讲座" class="headerlink" title="港科广LLM讲座"></a>港科广LLM讲座</h1><p>包括五部分内容：</p><ul><li>Resource Efficient LLM Fine-tuning</li><li>Qwen:Towards a GeneralistModel</li><li>LLM Evaluation andSafety at Naver</li><li>Challenges and PracticalApproaches to Design Privateand Scalable Information DataManagement Systems</li><li>Unlocking Generative Al withUbiquitous HW and Open SW</li><li>OCR for LLM</li></ul><h2 id="1-Resource-Efficient-LLM-Fine-tuning"><a href="#1-Resource-Efficient-LLM-Fine-tuning" class="headerlink" title="1. Resource Efficient LLM Fine-tuning"></a>1. Resource Efficient LLM Fine-tuning</h2><p>术语 ：</p><ul><li>PEFT:Parameter-Efficient Fine-Tuning(高效参数微调)</li><li>LoRA:Low-Rank Adapter(低秩适配器)</li><li>PEQA:Parameter-Efficient Quantization Aware Fine-Tuning(高效参数量化感知微调)</li><li>QLORA:Quantization-Aware Low-Rank Adapter(量化感知低秩适配器)</li></ul><h3 id="1-为什么需要PEFT"><a href="#1-为什么需要PEFT" class="headerlink" title="1. 为什么需要PEFT"></a>1. 为什么需要PEFT</h3><p><img src="/llm/LLMHKTG/a9f158715ccc23255c6764af6f66f56.jpg" alt="为什么需要PEFT"></p><h3 id="2-PEFT的进展"><a href="#2-PEFT的进展" class="headerlink" title="2. PEFT的进展"></a>2. PEFT的进展</h3><p><img src="/llm/LLMHKTG/2c1e7307759246338524818069df10b.jpg" alt="previous work"></p><h3 id="3-模型微调的若干方法"><a href="#3-模型微调的若干方法" class="headerlink" title="3. 模型微调的若干方法"></a>3. 模型微调的若干方法</h3><p><img src="/llm/LLMHKTG/image.png" alt="模型微调的若干方法"></p><ul><li><p>Prefix ： 在输入序列前加入一个特定的前缀，如“translate English to Chinese:”。</p></li><li><p>Adapter fine-tuning : 在原模型的中间层加入一个adapter层，只训练adapter层。最早来源于论文<a href="https://arxiv.org/pdf/1902.00751.pdf">《Parameter-Efficient Transfer Learning for NLP》</a><br><img src="/llm/LLMHKTG/image-1.png" alt="Adapter fine-tuning"></p></li><li><p>LoRA : 使用低秩分解矩阵. <a href="https://arxiv.org/pdf/2106.09685.pdf">论文</a>.<br><img src="/llm/LLMHKTG/image-2.png" alt="LoRA"></p></li></ul><p>在原始PLM (Pre-trained Language Model) 旁边增加一个旁路，做一个降维再升维的操作来模拟所谓的 intrinsic rank。训练的时候固定 PLM 的参数，只训练降维矩阵A与升维矩阵B。而模型的输入输出维度不变，输出时将 BA与 PLM 的参数叠加。用随机高斯分布初始化 4 ，用 0 矩阵初始化 B，保证训练的开始此旁路矩阵依然是0矩阵</p><ul><li>FISH Mask : 使用参数的FISH信息来计算掩模。</li></ul><h3 id="4-模型压缩"><a href="#4-模型压缩" class="headerlink" title="4. 模型压缩"></a>4. 模型压缩</h3><ul><li>QLORA : 将模型量化为4位精度并使用分页优化器。<a href="https://zhuanlan.zhihu.com/p/662817358">QLORA：高效微调量化LLM</a></li></ul><blockquote><p>4位NormalFloat（NF4）- 一种新的数据类型，对于正态分布的权重来说在信息论上是最优的。<br>双重量化 - 通过量化量化常数来减少平均内存占用。<br>分页优化器 - 用于管理内存峰值。</p></blockquote><ul><li>PEQA : 采用了双阶段过程运行。在第一阶段，每个全连接层的参数矩阵被量化为低比特整数矩阵和标量向量。在第二阶段，对每个特定下游任务的标量向量进行微调。论文：<a href="https://arxiv.org/abs/2305.14152">Memory-Efficient Fine-Tuning of Compressed Large Language Models via sub-4-bit Integer Quantization</a></li></ul><h3 id="5-PEFT的两大类"><a href="#5-PEFT的两大类" class="headerlink" title="5. PEFT的两大类"></a>5. PEFT的两大类</h3><p><img src="/llm/LLMHKTG/image-3.png" alt="PEFT的两大类"></p><ul><li>Adapter-based Fine-tuning</li><li>Sparse Fine-tuning</li></ul><h3 id="6-Limition"><a href="#6-Limition" class="headerlink" title="6. Limition"></a>6. Limition</h3><p><img src="/llm/LLMHKTG/8ae5da8f6ea19421b2a066e64a8c536.jpg" alt="Limition"></p><h3 id="7-作者的方法"><a href="#7-作者的方法" class="headerlink" title="7. 作者的方法"></a>7. 作者的方法</h3><p><img src="/llm/LLMHKTG/image-5.png" alt="Our Method"></p><p>实验结果：</p><p><img src="/llm/LLMHKTG/image-6.png" alt="实验结果"></p><p>前瞻：Model Merging</p><p><img src="/llm/LLMHKTG/image-7.png" alt="Model Merging"></p><p><img src="/llm/LLMHKTG/image-8.png" alt="Some prolems"></p><h2 id="2-Qwen-Towards-a-GeneralistModel"><a href="#2-Qwen-Towards-a-GeneralistModel" class="headerlink" title="2. Qwen:Towards a GeneralistModel"></a>2. Qwen:Towards a GeneralistModel</h2><p><img src="/llm/LLMHKTG/image-9.png" alt="Qwen"></p><p><img src="/llm/LLMHKTG/image-10.png" alt="Qwen"></p><h2 id="3-LLM-Evaluation-and-Safety-at-NAVER"><a href="#3-LLM-Evaluation-and-Safety-at-NAVER" class="headerlink" title="3. LLM Evaluation and Safety at NAVER"></a>3. LLM Evaluation and Safety at NAVER</h2><p><img src="/llm/LLMHKTG/image-11.png" alt="LLM Evaluation andSafety at Naver"></p><h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p><img src="/llm/LLMHKTG/image-12.png" alt="Why LLM Evaluation is import"></p><h3 id="Challenges-of-Human-LLM-Evaluation"><a href="#Challenges-of-Human-LLM-Evaluation" class="headerlink" title="Challenges of (Human) LLM Evaluation"></a>Challenges of (Human) LLM Evaluation</h3><p><img src="/llm/LLMHKTG/image-13.png" alt="Challenges"></p><p>敏感问题</p><p><img src="/llm/LLMHKTG/image-16.png" alt="Sensitive Questions"></p><h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3><ol><li>Prometheus</li></ol><p>在语言模型中引入细粒度评估能力.</p><p><img src="/llm/LLMHKTG/image-14.png" alt="Prometheus"></p><p><img src="/llm/LLMHKTG/image-15.png" alt="Prometheus"></p><ol start="2"><li>SQuARe</li></ol><p><a href="https://arxiv.org/abs/2305.17696">SQuARe: A Large-Scale Dataset of Sensitive Questions and Acceptable Responses Created Through Human-Machine Collaboration</a></p><p>这篇论文主要关注大型语言模型可能带来的社会危害，如生成冒犯性内容和强化偏见。尽管现有的工作主要集中在与恶意用户交互时应对这个问题，但即使用户的初衷是好的，讨论敏感问题也可能变得有毒。为了在这种情况下有更安全的模型，论文提出了一个名为SQuARe（Sensitive Questions and Acceptable Response）的数据集，这是一个大规模的韩语数据集，包含49k个敏感问题以及42k个可接受和46k个不可接受的回答。</p><ol start="3"><li>KoSBi</li></ol><p><a href="https://arxiv.org/abs/2305.17701">KoSBi: A Dataset for Mitigating Social Bias Risks Towards Safer Large Language Model Application</a></p><p>这篇论文主要关注大型语言模型（LLMs）从现实世界的数据中学习自然文本生成能力的同时，也学习了针对不同人口群体的社会偏见，这在部署基于LLM的应用时构成了重要风险。由于语言和文化的差异，现有的研究和资源在韩国并不容易应用，这两个因素都显著影响了偏见和目标人口群体。这种局限性需要本地化的社会偏见数据集，以确保LLM的安全有效部署。为此，论文提出了KO SB I，这是一个新的社会偏见数据集，包含34k对韩语的上下文和句子，涵盖了15个类别的72个人口群体。研究发现，通过基于过滤的调节，可以将HyperCLOVA（30B和82B）和GPT-3生成内容中的社会偏见平均减少16.47%。</p><h2 id="4-Challenges-and-PracticalApproaches-to-Design-Privateand-Scalable-Information-DataManagement-Systems"><a href="#4-Challenges-and-PracticalApproaches-to-Design-Privateand-Scalable-Information-DataManagement-Systems" class="headerlink" title="4. Challenges and PracticalApproaches to Design Privateand Scalable Information DataManagement Systems"></a>4. Challenges and PracticalApproaches to Design Privateand Scalable Information DataManagement Systems</h2><p>ORAM : Oblivious Random Access Machine (不经意随机访问机)</p><p>ORAM（Oblivious RAM）是一种隐私保护技术，用于在云存储等场景中保护用户数据的隐私。它通过在访问存储时隐藏访问模式，以防止任何有意或无意的信息泄露。</p><p><img src="/llm/LLMHKTG/image-17.png" alt="ORAM"></p><p>几种实现方式</p><ul><li>PATH ORAM : 通过树状结构实现,每次访问时都会将整个路径上的数据重新加密并重新排列，以隐藏访问模式。</li><li>Cuckoo ORAM : 通过哈希表实现，每次访问时都会将数据重新加密并重新排列，以隐藏访问模式。</li><li>Ring ORAM : Ring ORAM 是一种基于环形结构的ORAM方法，通过将数据存储在环上并以随机的顺序进行排列，以隐藏访问模式。这种方法通常比Path ORAM具有更低的复杂度。</li></ul><p><a href="https://www.jos.org.cn/jos/article/abstract/5591">不经意随机访问机研究综述</a></p><h2 id="5-Unlocking-Generative-Al-with-Ubiquitous-HW-and-Open-SW"><a href="#5-Unlocking-Generative-Al-with-Ubiquitous-HW-and-Open-SW" class="headerlink" title="5. Unlocking Generative Al with Ubiquitous HW and Open SW"></a>5. Unlocking Generative Al with Ubiquitous HW and Open SW</h2><blockquote><p>Intel 大模型AI开发团队<br>Intel NeuralChat - <a href="https://huggingface.co/Intel/neural-chat-7b-v3-3">https://huggingface.co/Intel/neural-chat-7b-v3-3</a></p></blockquote><p><img src="/llm/LLMHKTG/image-18.png" alt="NeuralChat"></p><p>基于Mistral-7B，使用开源数据集SlimOrca，使用DPO(Direct Preference Optimization)算法进行对齐. 对齐的详细介绍:<a href="https://medium.com/intel-analytics-software/the-practice-of-supervised-finetuning-and-direct-preference-optimization-on-habana-gaudi2-a1197d8a3cd3">Supervised Fine-Tuning and Direct Preference Optimization on Intel Gaudi2</a></p><ul><li>Intel Extension For Transformers : </li><li>Intel Gaudi2加速器 : 深度学习计算卡</li><li>DPO算法 : 引导LMs匹配人类偏好，DPO&#x2F;RLHF <a href="https://zhuanlan.zhihu.com/p/634705904">DPO</a></li></ul><p><img src="/llm/LLMHKTG/image-19.png" alt="DPO"></p><ul><li>Intel Neural Compressor</li><li>SignRound:New INT4 LLM Quantization Recipe</li><li>Al Augmentation</li></ul><p><img src="/llm/LLMHKTG/image-20.png" alt="Al Augmentation"></p><ul><li>AI Safety</li></ul><p><img src="/llm/LLMHKTG/image-21.png" alt="AI Safety"></p><h2 id="6-OCR-for-LLM"><a href="#6-OCR-for-LLM" class="headerlink" title="6. OCR for LLM"></a>6. OCR for LLM</h2><ol><li>LLM Stack</li></ol><p><img src="/llm/LLMHKTG/image-22.png" alt="LLM Stack"></p><ol start="2"><li>Input and Output</li></ol><p><img src="/llm/LLMHKTG/image-23.png" alt="Input &amp; Output"></p><ol start="3"><li>Modules of OCR for LLM</li></ol><p><img src="/llm/LLMHKTG/image-24.png" alt="Modules"></p><p><img src="/llm/LLMHKTG/image-25.png" alt="Donut base architecture"></p><ol start="4"><li>Requests for research</li></ol><p><img src="/llm/LLMHKTG/image-26.png" alt="Requests"></p><ul><li>多任务学习在布局分析和序列化中的应用。而不是使用单独的模型来进行布局分析和序列化，而是开发一个统一的模型。它可以是一个生成模型，如donut，但应该在质量和速度方面更优越。</li><li>序列化评估度量的开发。什么才是定量评估阅读顺序的一个很好的衡量标准？地图，准确性，蓝牙吗？它也适用于长文档吗？</li><li>信息图形文本。以文本格式表示信息图形和&#x2F;或图像的最佳方式是什么。图像字幕是最具代表性的格式吗？</li></ul>]]></content>
    
    
    <categories>
      
      <category>大模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变分自编码器（VAE）</title>
    <link href="/llm/VAE/"/>
    <url>/llm/VAE/</url>
    
    <content type="html"><![CDATA[<p>变分自编码器（Variational Autoencoder, VAE）是一种生成模型，结合了概率图模型和深度学习的优点。VAE 通过学习数据的潜在表示来生成新的数据样本。与传统的自编码器不同，VAE 在编码器部分引入了概率分布，使得生成的潜在表示具有更好的连续性和可操作性。</p><h3 id="VAE-的模型结构"><a href="#VAE-的模型结构" class="headerlink" title="VAE 的模型结构"></a>VAE 的模型结构</h3><p>VAE 的模型结构主要包括两个部分：编码器（Encoder）和解码器（Decoder）。</p><ol><li><strong>编码器（Encoder）</strong>：将输入数据映射到潜在空间的概率分布，通常是高斯分布。编码器输出潜在变量的均值和方差。</li><li><strong>解码器（Decoder）</strong>：从潜在空间的样本生成数据。解码器将潜在变量映射回原始数据空间。</li></ol><h3 id="VAE-的用途"><a href="#VAE-的用途" class="headerlink" title="VAE 的用途"></a>VAE 的用途</h3><p>VAE 可以用于以下任务：</p><ul><li>数据生成：生成与训练数据相似的新数据样本。</li><li>数据降维：将高维数据映射到低维潜在空间。</li><li>图像生成和重建：生成和重建图像数据。</li><li>异常检测：通过检测潜在空间中的异常点来识别异常数据。</li></ul><h3 id="使用-PyTorch-实现-VAE"><a href="#使用-PyTorch-实现-VAE" class="headerlink" title="使用 PyTorch 实现 VAE"></a>使用 PyTorch 实现 VAE</h3><p>以下是一个使用 PyTorch 实现的简单变分自编码器（VAE）示例。示例使用 MNIST 数据集来训练 VAE 模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> datasets, transforms<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><br><span class="hljs-comment"># 定义编码器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Encoder</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, input_dim, hidden_dim, latent_dim</span>):<br>        <span class="hljs-built_in">super</span>(Encoder, self).__init__()<br>        self.fc1 = nn.Linear(input_dim, hidden_dim)<br>        self.fc2_mean = nn.Linear(hidden_dim, latent_dim)<br>        self.fc2_log_var = nn.Linear(hidden_dim, latent_dim)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        h = torch.relu(self.fc1(x))<br>        mean = self.fc2_mean(h)<br>        log_var = self.fc2_log_var(h)<br>        <span class="hljs-keyword">return</span> mean, log_var<br><br><span class="hljs-comment"># 定义解码器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Decoder</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, latent_dim, hidden_dim, output_dim</span>):<br>        <span class="hljs-built_in">super</span>(Decoder, self).__init__()<br>        self.fc1 = nn.Linear(latent_dim, hidden_dim)<br>        self.fc2 = nn.Linear(hidden_dim, output_dim)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, z</span>):<br>        h = torch.relu(self.fc1(z))<br>        x_reconstructed = torch.sigmoid(self.fc2(h))<br>        <span class="hljs-keyword">return</span> x_reconstructed<br><br><span class="hljs-comment"># 定义 VAE 模型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VAE</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, input_dim, hidden_dim, latent_dim</span>):<br>        <span class="hljs-built_in">super</span>(VAE, self).__init__()<br>        self.encoder = Encoder(input_dim, hidden_dim, latent_dim)<br>        self.decoder = Decoder(latent_dim, hidden_dim, input_dim)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        mean, log_var = self.encoder(x)<br>        std = torch.exp(<span class="hljs-number">0.5</span> * log_var)<br>        epsilon = torch.randn_like(std)<br>        z = mean + std * epsilon<br>        x_reconstructed = self.decoder(z)<br>        <span class="hljs-keyword">return</span> x_reconstructed, mean, log_var<br><br><span class="hljs-comment"># 定义损失函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">vae_loss</span>(<span class="hljs-params">x, x_reconstructed, mean, log_var</span>):<br>    reconstruction_loss = nn.functional.binary_cross_entropy(x_reconstructed, x, reduction=<span class="hljs-string">&#x27;sum&#x27;</span>)<br>    kl_divergence = -<span class="hljs-number">0.5</span> * torch.<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span> + log_var - mean.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>) - log_var.exp())<br>    <span class="hljs-keyword">return</span> reconstruction_loss + kl_divergence<br><br><span class="hljs-comment"># 加载数据</span><br>transform = transforms.ToTensor()<br>train_dataset = datasets.MNIST(root=<span class="hljs-string">&#x27;./data&#x27;</span>, train=<span class="hljs-literal">True</span>, transform=transform, download=<span class="hljs-literal">True</span>)<br>train_loader = DataLoader(train_dataset, batch_size=<span class="hljs-number">64</span>, shuffle=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 创建模型</span><br>input_dim = <span class="hljs-number">28</span> * <span class="hljs-number">28</span><br>hidden_dim = <span class="hljs-number">256</span><br>latent_dim = <span class="hljs-number">20</span><br>vae = VAE(input_dim, hidden_dim, latent_dim)<br><br><span class="hljs-comment"># 定义优化器</span><br>optimizer = optim.Adam(vae.parameters(), lr=<span class="hljs-number">1e-3</span>)<br><br><span class="hljs-comment"># 训练模型</span><br>num_epochs = <span class="hljs-number">20</span><br>vae.train()<br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):<br>    total_loss = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> batch_idx, (data, _) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_loader):<br>        data = data.view(-<span class="hljs-number">1</span>, input_dim)<br>        optimizer.zero_grad()<br>        x_reconstructed, mean, log_var = vae(data)<br>        loss = vae_loss(data, x_reconstructed, mean, log_var)<br>        loss.backward()<br>        optimizer.step()<br>        total_loss += loss.item()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Epoch <span class="hljs-subst">&#123;epoch + <span class="hljs-number">1</span>&#125;</span>, Loss: <span class="hljs-subst">&#123;total_loss / <span class="hljs-built_in">len</span>(train_loader.dataset)&#125;</span>&#x27;</span>)<br><br><span class="hljs-comment"># 保存模型</span><br>torch.save(vae.state_dict(), <span class="hljs-string">&#x27;vae.pth&#x27;</span>)<br></code></pre></td></tr></table></figure><p>以上示例展示了如何使用 PyTorch 实现一个简单的 VAE 模型。编码器将输入数据映射到潜在空间的均值和方差，解码器从潜在空间的样本生成数据。损失函数包括重建损失和 KL 散度，用于平衡生成数据的质量和潜在空间的连续性。</p>]]></content>
    
    
    <categories>
      
      <category>大模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Neo4j和LangChain集成非结构化和图知识增强QA</title>
    <link href="/llm/mistral-langchain-neo4j/"/>
    <url>/llm/mistral-langchain-neo4j/</url>
    
    <content type="html"><![CDATA[<h1 id="使用Neo4j和LangChain集成非结构化和图知识增强QA"><a href="#使用Neo4j和LangChain集成非结构化和图知识增强QA" class="headerlink" title="使用Neo4j和LangChain集成非结构化和图知识增强QA"></a>使用Neo4j和LangChain集成非结构化和图知识增强QA</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是对项目<a href="https://mp.weixin.qq.com/s/iHS5wl_Xzv_FKkdNISjJcw"><em>使用Neo4j和LangChain集成非结构化和图知识增强QA</em></a>的复现。该项目主要目的是借助向量索引加快构建知识图谱。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p><strong>LangChain</strong></p><p>LangChain加速大语言模型应用开发的套件，其集成了本地数据加载，LLM模型的调用等，方便LLM对外部数据源的调用，方便进行与LLM的交互。对于LLM的使用，可参考<a href="https://liaokong.gitbook.io/llm-kai-fa-jiao-cheng">LangChain中文入门教程</a>.</p><p><strong>Neo4j</strong></p><p>Neo4j是一个高性能的图数据库，它将结构化数据存储在网络上而不是表中。关于Neo4j的使用，可参考<a href="https://neo4j.com/docs/getting-started/">Neo4j官方文档</a>.</p><p><strong>Mistral</strong></p><p>Mistral是一个较新的大语言模型，尤其是mistral-7B，是目前综合性能最好的7B模型。关于Mistral的使用，可参考<a href="https://docs.mistral.ai/">Mistral官方文档</a>.</p><h2 id="复现流程"><a href="#复现流程" class="headerlink" title="复现流程"></a>复现流程</h2><h3 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1. 安装依赖"></a>1. 安装依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install langchain openai wikipedia tiktoken neo4j python-dotenv transformers<br></code></pre></td></tr></table></figure><h3 id="2-安装Neo4j数据库"><a href="#2-安装Neo4j数据库" class="headerlink" title="2. 安装Neo4j数据库"></a>2. 安装Neo4j数据库</h3><p>参考neo4j官方文档<a href="https://neo4j.com/docs/operations-manual/current/installation/linux/debian/">Debian-based distributions</a>。Neo4J的dep安装包可从<a href="https://neo4j.com/deployment-center/#gdb-tab">Neo4j官网</a>下载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装JDK17</span><br>sudo apt install openjdk-17-jdk-headless<br><br><span class="hljs-comment"># 添加Neo4j的源</span><br>wget -O - https://debian.neo4j.com/neotechnology.gpg.key | sudo apt-key add -<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;deb https://debian.neo4j.com stable 4.3&#x27;</span> | sudo <span class="hljs-built_in">tee</span> -a /etc/apt/sources.list.d/neo4j.list<br>sudo apt-get update<br><br><span class="hljs-comment"># 安装neo4j的dep文件</span><br>dpkg -i neo4j_5.14.0_all.deb<br><br><span class="hljs-comment"># 启动neo4j</span><br>neo4j start<br><br><span class="hljs-comment"># 注意，安装neo4j的dep文件时，可能会遇到依赖缺失的问题，执行下述命令补全依赖即可</span><br>sudo apt --fix-broken install<br><br><span class="hljs-comment"># 修改默认密码</span><br>neo4j-admin dbms set-initial-password pwdofneo4j<br></code></pre></td></tr></table></figure><h2 id="从非结构化数据构建知识图谱"><a href="#从非结构化数据构建知识图谱" class="headerlink" title="从非结构化数据构建知识图谱"></a>从非结构化数据构建知识图谱</h2><p>三个问题，参见<a href="https://medium.com/neo4j/construct-knowledge-graphs-from-unstructured-text-877be33300a2">Neo4J开发人员博客</a>。</p><ol><li>Extracting nodes and relationships</li><li>Entity disambiguation</li><li>Importing into Neo4j</li></ol><h3 id="Extracting-nodes-and-relationships"><a href="#Extracting-nodes-and-relationships" class="headerlink" title="Extracting nodes and relationships"></a>Extracting nodes and relationships</h3><p>将<code>inout text</code>分割成适合<code>context window</code>大小的<code>chunk</code>，输入LLM，使其提取出<code>entities</code>和<code>relations</code>，并按一定格式输出，每个<code>chunk</code>与前一个<code>chunk</code>设置有重叠部分，以保证<code>entities</code>和<code>relations</code>的完整性。为了保持跨块不同类型实体的标记的一致性，向LLM提供了在先前块中提取的节点类型列表。</p><h3 id="Entity-disambiguation"><a href="#Entity-disambiguation" class="headerlink" title="Entity disambiguation"></a>Entity disambiguation</h3><p>将<code>entities</code>按类型分组，将每一组分别提供给LLM，借助LLM消除重复实体并合并属性。</p><h3 id="Importing-into-Neo4j"><a href="#Importing-into-Neo4j" class="headerlink" title="Importing into Neo4j"></a>Importing into Neo4j</h3><p>将LLM输出的<code>entities</code>和<code>relations</code>转为CSV格式，借助neo4j的<code>LOAD CSV</code>命令导入到neo4j中。</p>]]></content>
    
    
    <categories>
      
      <category>大模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>LangChain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GO语言入门</title>
    <link href="/go/go-starter/"/>
    <url>/go/go-starter/</url>
    
    <content type="html"><![CDATA[<h1 id="1-GO语言简介"><a href="#1-GO语言简介" class="headerlink" title="1 GO语言简介"></a>1 GO语言简介</h1><h2 id="1-1-什么是GO语言"><a href="#1-1-什么是GO语言" class="headerlink" title="1.1 什么是GO语言"></a>1.1 什么是GO语言</h2><p>Go语言是谷歌2009发布的第二款开源编程语言，它是一门编译型语言，它结合了解释型语言的游刃有余，动态类型语言的开发效率，以及静态类型语言的安全性。go语言支持并发、垃圾回收、快速编译（同时支持交叉编译）、内存安全（没有指针）、丰富的内置类型、函数返回多值、错误处理、匿名函数和闭包、类型和接口、运行时反射、安全的并行机制、编译时代码生成（通过反射）、语言交互性（C语言调用go编译的动态库，go调用C语言编译的动态库）、自动垃圾回收、更丰富的标准库等特性。go语言目前常用在Web 开发、分布式系统、云平台、网络服务、系统工具开发、自动化运维、云计算、云存储、云网络、网络安全、游戏开发等领域。常见的由go语言开发的产品有Docker、Kubernetes等。</p><h2 id="1-2-安装GO语言"><a href="#1-2-安装GO语言" class="headerlink" title="1.2 安装GO语言"></a>1.2 安装GO语言</h2><p>参照<a href="https://golang.org/doc/install">官方指南</a>安装go语言，安装完成后，执行<code>go version</code>查看go语言版本。如果执行成功，则安装成功。</p><h2 id="1-3-第一个GO语言程序"><a href="#1-3-第一个GO语言程序" class="headerlink" title="1.3 第一个GO语言程序"></a>1.3 第一个GO语言程序</h2><p>创建一个<code>hello.go</code>文件，内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行<code>go run hello.go</code>，输出<code>Hello, World!</code>。其中<code>package main</code>表示这是一个可独立执行的程序，<code>import &quot;fmt&quot;</code>表示引入了一个包，<code>fmt</code>包实现了格式化IO（输入&#x2F;输出）的函数。 <code>func main()</code>是程序开始执行的函数，<code>main</code>函数是每一个可执行程序所必须包含的，<code>main</code>函数只能由<code>package main</code>声明一次。<code>fmt.Println</code>可以将字符串输出到控制台，并在最后自动增加换行字符<code>\n</code>。</p><h1 id="2-变量声明"><a href="#2-变量声明" class="headerlink" title="2 变量声明"></a>2 变量声明</h1><h2 id="2-1-变量类型"><a href="#2-1-变量类型" class="headerlink" title="2.1 变量类型"></a>2.1 变量类型</h2><p>go语言的基本类型有<code>bool</code>、<code>string</code>、<code>int</code>、<code>int8</code>、<code>int16</code>、<code>int32</code>、<code>int64</code>、<code>uint</code>、<code>uint8</code>、<code>uint16</code>、<code>uint32</code>、<code>uint64</code>、<code>uintptr</code>、<code>byte</code>、<code>rune</code>、<code>float32</code>、<code>float64</code>、<code>complex64</code>、<code>complex128</code>。其中<code>int</code>、<code>uint</code>、<code>uintptr</code>在32位系统上是32位，在64位系统上是64位。<code>byte</code>是<code>uint8</code>的别名，<code>rune</code>是<code>int32</code>的别名。<code>complex64</code>和<code>complex128</code>分别是32位和64位大小的复数类型。</p><h2 id="2-2-四种声明方式"><a href="#2-2-四种声明方式" class="headerlink" title="2.2 四种声明方式"></a>2.2 四种声明方式</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> name <span class="hljs-keyword">type</span> <span class="hljs-comment">// 声明变量，如果不初始化，则变量默认为零值。</span><br><span class="hljs-keyword">var</span> name <span class="hljs-keyword">type</span> = value <span class="hljs-comment">// 声明变量，并初始化。</span><br><span class="hljs-keyword">var</span> name = value <span class="hljs-comment">// 声明变量，根据值自行判定变量类型。</span><br>name := value <span class="hljs-comment">// 简短声明，只能用在函数内部，用于声明局部变量。</span><br></code></pre></td></tr></table></figure><h2 id="2-3-多变量声明"><a href="#2-3-多变量声明" class="headerlink" title="2.3 多变量声明"></a>2.3 多变量声明</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> name1, name2 <span class="hljs-keyword">type</span> <span class="hljs-comment">// 声明多个同类型变量。</span><br><span class="hljs-keyword">var</span> name1, name2 <span class="hljs-keyword">type</span> = value1, value2 <span class="hljs-comment">// 声明多个同类型变量，并初始化。</span><br><span class="hljs-keyword">var</span> name1, name2 = value1, value2 <span class="hljs-comment">// 声明多个同类型变量，根据值自行判定变量类型。</span><br>name1, name2 := value1, value2 <span class="hljs-comment">// 简短声明，只能用在函数内部，用于声明局部变量。</span><br></code></pre></td></tr></table></figure><h2 id="2-4-匿名变量"><a href="#2-4-匿名变量" class="headerlink" title="2.4 匿名变量"></a>2.4 匿名变量</h2><p>匿名变量用<code>_</code>表示，匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">string</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>, <span class="hljs-string">&quot;bar&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    x, _ := foo()<br>    _, y := foo()<br>    fmt.Println(<span class="hljs-string">&quot;x=&quot;</span>, x)<br>    fmt.Println(<span class="hljs-string">&quot;y=&quot;</span>, y)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-5-常量"><a href="#2-5-常量" class="headerlink" title="2.5 常量"></a>2.5 常量</h2><p>常量是一个简单值的标识符，在程序运行时，不会被修改的量。常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> name = value<br><span class="hljs-keyword">const</span> name <span class="hljs-keyword">type</span> = value<br></code></pre></td></tr></table></figure><p><code>iota</code>是 go 语言的常量计数器，只能在常量的表达式中使用。<code>iota</code>在<code>const</code>关键字出现时将被重置为<code>0</code>，<code>const</code>中每新增一行常量声明将使<code>iota</code>计数一次（<code>iota</code>可理解为<code>const</code>语句块中的行索引）。使用<code>iota</code>能简化定义，在定义枚举时很有用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    a = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 0</span><br>    b        <span class="hljs-comment">// 1</span><br>    c        <span class="hljs-comment">// 2</span><br>    d = <span class="hljs-string">&quot;ha&quot;</span> <span class="hljs-comment">// 独立值，iota += 1</span><br>    e        <span class="hljs-comment">// &quot;ha&quot;   iota += 1</span><br>    f = <span class="hljs-number">100</span>  <span class="hljs-comment">// iota +=1</span><br>    g        <span class="hljs-comment">// 100  iota +=1</span><br>    h = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 7,恢复计数</span><br>    i        <span class="hljs-comment">// 8</span><br>)<br></code></pre></td></tr></table></figure><h1 id="3-函数"><a href="#3-函数" class="headerlink" title="3 函数"></a>3 函数</h1><h2 id="3-1-函数定义"><a href="#3-1-函数定义" class="headerlink" title="3.1 函数定义"></a>3.1 函数定义</h2><p>GO语言的函数与C语言的函数定义类似，但是GO语言支持多返回值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">funcName</span><span class="hljs-params">(input1 type1, input2 type2)</span></span> (output1 type1, output2 type2) &#123;<br>    <span class="hljs-comment">// 这里是处理逻辑代码</span><br>    <span class="hljs-comment">// 返回多个值</span><br>    <span class="hljs-keyword">return</span> value1, value2<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-函数调用"><a href="#3-2-函数调用" class="headerlink" title="3.2 函数调用"></a>3.2 函数调用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 调用函数</span><br>    value1, value2 := funcName(param1, param2)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-函数返回值"><a href="#3-3-函数返回值" class="headerlink" title="3.3 函数返回值"></a>3.3 函数返回值</h2><p>go语言支持多返回值，函数定义时需要定义返回值类型，函数返回时需要返回相应数量、类型的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 返回值匿名</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum1</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b, a - b<br>&#125;<br><br><span class="hljs-comment">// 返回值命名</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum2</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> (x <span class="hljs-type">int</span>, y <span class="hljs-type">int</span>) &#123;<br>    x = a + b<br>    y = a - b<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    x, y := sum1(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>    fmt.Println(<span class="hljs-string">&quot;x=&quot;</span>, x)<br>    fmt.Println(<span class="hljs-string">&quot;y=&quot;</span>, y)<br><br>    x1, y1 = sum2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>    fmt.Println(<span class="hljs-string">&quot;x=&quot;</span>, x1)<br>    fmt.Println(<span class="hljs-string">&quot;y=&quot;</span>, y1)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-4-函数作为参数"><a href="#3-4-函数作为参数" class="headerlink" title="3.4 函数作为参数"></a>3.4 函数作为参数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calc</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>, op <span class="hljs-keyword">func</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> op(a, b)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    x := calc(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, sum)<br>    fmt.Println(<span class="hljs-string">&quot;x=&quot;</span>, x)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-5-函数作为返回值"><a href="#3-5-函数作为返回值" class="headerlink" title="3.5 函数作为返回值"></a>3.5 函数作为返回值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">switch</span> s &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>            <span class="hljs-keyword">return</span> a + b<br>        &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>            <span class="hljs-keyword">return</span> a - b<br>        &#125;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    x := do(<span class="hljs-string">&quot;+&quot;</span>)<br>    y := x(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>    fmt.Println(<span class="hljs-string">&quot;y=&quot;</span>, y)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-6-闭包"><a href="#3-6-闭包" class="headerlink" title="3.6 闭包"></a>3.6 闭包</h2><p>闭包是引用了外部变量的函数，被引用的变量和函数一同存在，即使函数已经离开了声明所在的环境，但是引用的变量仍然存在，闭包使得这些变量的生命周期延长了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">adder</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> x <span class="hljs-type">int</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(d <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>        x += d<br>        <span class="hljs-keyword">return</span> x<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    x := adder()<br>    y := x(<span class="hljs-number">1</span>)<br>    fmt.Println(<span class="hljs-string">&quot;y=&quot;</span>, y)<br>    y = x(<span class="hljs-number">2</span>)<br>    fmt.Println(<span class="hljs-string">&quot;y=&quot;</span>, y)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-7-defer"><a href="#3-7-defer" class="headerlink" title="3.7 defer"></a>3.7 defer</h2><p><code>defer</code>语句会将其后面跟随的语句进行延迟处理。在<code>defer</code>归属的函数即将返回时，将延迟处理的语句按<code>defer</code>定义的逆序进行执行，也就是说，先被<code>defer</code>的语句最后被执行，最后被<code>defer</code>的语句，最先被执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;world&quot;</span>)<br>    fmt.Println(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-8-panic"><a href="#3-8-panic" class="headerlink" title="3.8 panic"></a>3.8 panic</h2><p><code>panic</code>用于报告一个严重错误，通常发生在不可恢复的错误，如数组越界、空指针引用等，这些运行时错误会引起<code>panic</code>异常。<code>panic</code>异常发生时，程序会中断运行，并立即执行在该<code>goroutine</code>中被延迟的函数调用，之后程序崩溃并输出日志信息。<code>panic</code>可以直接调用<code>panic</code>函数，也可以由运行时错误触发。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;a problem&quot;</span>)<br><br>    _, err := os.Create(<span class="hljs-string">&quot;/tmp/file&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-9-recover"><a href="#3-9-recover" class="headerlink" title="3.9 recover"></a>3.9 recover</h2><p><code>recover</code>用于终止错误处理流程，<code>recover</code>只能在<code>defer</code>修饰的函数中使用，用于取得<code>panic</code>调用中传递过来的错误值，如果是正常执行，调用<code>recover</code>会返回<code>nil</code>，并且没有其它效果，如果当前的<code>goroutine</code>陷入<code>panic</code>状态，调用<code>recover</code>可以捕获到<code>panic</code>的输入值，并且恢复正常执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>            fmt.Println(err)<br>        &#125;<br>    &#125;()<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;a problem&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-流程控制"><a href="#4-流程控制" class="headerlink" title="4 流程控制"></a>4 流程控制</h1><h2 id="4-1-if"><a href="#4-1-if" class="headerlink" title="4.1 if"></a>4.1 if</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> condition &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> condition &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-2-switch"><a href="#4-2-switch" class="headerlink" title="4.2 switch"></a>4.2 switch</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> condition &#123;<br><span class="hljs-keyword">case</span> condition:<br>    <span class="hljs-comment">// do something</span><br><span class="hljs-keyword">case</span> condition:<br>    <span class="hljs-comment">// do something</span><br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-3-for"><a href="#4-3-for" class="headerlink" title="4.3 for"></a>4.3 for</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> init; condition; post &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-4-for-range"><a href="#4-4-for-range" class="headerlink" title="4.4 for range"></a>4.4 for range</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> oldMap &#123;<br>    newMap[key] = value<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-5-break"><a href="#4-5-break" class="headerlink" title="4.5 break"></a>4.5 break</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>    <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">5</span> &#123;<br>        <span class="hljs-keyword">break</span><br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;i=&quot;</span>, i)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-6-continue"><a href="#4-6-continue" class="headerlink" title="4.6 continue"></a>4.6 continue</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">5</span> &#123;<br>        <span class="hljs-keyword">continue</span><br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;i=&quot;</span>, i)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-7-goto"><a href="#4-7-goto" class="headerlink" title="4.7 goto"></a>4.7 goto</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    i := <span class="hljs-number">0</span><br>Here:<br>    fmt.Println(<span class="hljs-string">&quot;i=&quot;</span>, i)<br>    i++<br>    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">10</span> &#123;<br>        <span class="hljs-keyword">goto</span> Here<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-数组"><a href="#5-数组" class="headerlink" title="5 数组"></a>5 数组</h1><h2 id="5-1-数组定义"><a href="#5-1-数组定义" class="headerlink" title="5.1 数组定义"></a>5.1 数组定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> variable_name [SIZE] variable_type<br></code></pre></td></tr></table></figure><h2 id="5-2-数组初始化"><a href="#5-2-数组初始化" class="headerlink" title="5.2 数组初始化"></a>5.2 数组初始化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> balance = [<span class="hljs-number">5</span>]<span class="hljs-type">float32</span>&#123;<span class="hljs-number">1000.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.4</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">50.0</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-3-数组访问"><a href="#5-3-数组访问" class="headerlink" title="5.3 数组访问"></a>5.3 数组访问</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> salary <span class="hljs-type">float32</span> = balance[<span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><h2 id="5-4-数组长度"><a href="#5-4-数组长度" class="headerlink" title="5.4 数组长度"></a>5.4 数组长度</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">len</span>(balance)<br></code></pre></td></tr></table></figure><h2 id="5-5-数组遍历"><a href="#5-5-数组遍历" class="headerlink" title="5.5 数组遍历"></a>5.5 数组遍历</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(balance); i++ &#123;<br>    fmt.Println(balance[i])<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-6-多维数组"><a href="#5-6-多维数组" class="headerlink" title="5.6 多维数组"></a>5.6 多维数组</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> threedim [<span class="hljs-number">5</span>][<span class="hljs-number">10</span>][<span class="hljs-number">4</span>]<span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><h1 id="三种导入方式"><a href="#三种导入方式" class="headerlink" title="三种导入方式"></a>三种导入方式</h1><h2 id="1-import-“fmt”"><a href="#1-import-“fmt”" class="headerlink" title="1. import . “fmt”"></a>1. import . “fmt”</h2><p>在导入包后，调用包中函数时可以省略包名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> . <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    Println(<span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-import-“fmt”"><a href="#2-import-“fmt”" class="headerlink" title="2. import _ “fmt”"></a>2. import _ “fmt”</h2><p>导入包，但是不使用包中函数，而是调用了该包中的<code>init</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> _ <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 调用了fmt包中的init函数</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-import-“fmt”"><a href="#3-import-“fmt”" class="headerlink" title="3. import “fmt”"></a>3. import “fmt”</h2><p>导入包，调用包中函数时，需要带上包名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>GO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用Hexo搭建个人博客</title>
    <link href="/hexo-starter/"/>
    <url>/hexo-starter/</url>
    
    <content type="html"><![CDATA[<p><a href="https://hexo.io/">Hexo</a> 是一个基于 Node.js 的静态博客框架，可以帮助用户快速搭建个人博客网站。使用 Hexo，可以使用 Markdown 语法编写文章，然后将其转换为静态 HTML 页面，最后发布到网站上。</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx init<br></code></pre></td></tr></table></figure><p>项目的大致目录结构如下：</p><p><img src="/hexo-starter/image-1.png" alt="项目目录结构"></p><p>其中，<code>_config.yml</code> 是项目的配置文件，<code>source</code> 目录存放源文件，<code>themes</code> 目录存放主题文件，<code>public</code> 目录存放生成的静态文件。<code>scaffolds</code> 目录存放模板文件，默认有三个模板文件：<code>draft.md</code>、<code>page.md</code>、<code>post.md</code>，分别对应草稿、页面、文章。文章就是一般意思上的一篇博客，页面则是一些静态页面，比如关于页面、友情链接页面等。所谓模板则是指执行<code>hexo new</code> 命令时，会根据模板文件生成对应的文件，即填充模板文件中的内容。</p><p><code>_config.yml</code> 文件是全局配置文件，可设置网站标题，作者，描述，主题，部署等信息。</p><h3 id="新建博客"><a href="#新建博客" class="headerlink" title="新建博客"></a>新建博客</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>执行<code>hexo new [layout]</code>命令可以新建草稿，文章或页面，<code>layout</code>也即新建内容的类型(草稿，文章或页面)，默认为<code>post</code>，即新建文章。执行该命令后，会在<code>source/_posts</code>目录下生成一个<code>My New Post.md</code>文件，其内容如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: My New Post<br>date: 2023-10-21 11:11:33<br>category: example<span class="hljs-emphasis">_category</span><br><span class="hljs-emphasis">tags:</span><br><span class="hljs-emphasis">    - tag1</span><br><span class="hljs-emphasis">    - tag2</span><br><span class="hljs-emphasis">---</span><br></code></pre></td></tr></table></figure><p><code>category</code>为文章分类，可理解为文章所在的目录，<code>tags</code>为文章标签，<code>date</code>为文章创建时间，<code>title</code>为文章标题。在该文件中以markdown语法书写博客，更多信息可参考<a href="https://hexo.io/docs/writing.html">官方文档</a></p><h3 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h3><p>Hexo提供了一些默认主题，可在<code>themes</code>目录下找到，也可以在<a href="https://hexo.io/themes/">官方主题库</a>中找到更多主题。下载到<code>themes</code>文件夹下，在全局<code>_config.yml</code>文件中修改<code>theme</code>字段为主题名称即可。这里题主使用的是Fluid主题，根据其<a href="https://github.com/fluid-dev/hexo-theme-fluid">官方文档</a>进行配置即可。</p><h3 id="图片引用"><a href="#图片引用" class="headerlink" title="图片引用"></a>图片引用</h3><p>在markdown中引入图片时，可以使用图床也可以使用本地文件。如果使用本地文件，需要将图片放在<code>source/images</code>目录下，然后在markdown中使用相对路径引用即可。也可以针对每个文章单独建立一个目录，将图片放在该目录下，然后在markdown中使用相对路径引用，这种情况需要在<code>_config.yml</code>文件中设置<code>post_asset_folder: true</code>，这样在执行<code>hexo new</code>命令时，会在<code>source/_posts</code>目录下为每个文章新建一个同名目录，该目录下存放文章的图片。</p><p>题主推荐使用插件<a href="https://github.com/hexojs/hexo-renderer-marked">hexo-render-marked</a>，该插件支持直接解析markdown语法的图片引用，即可以直接使用<code>![image](./image.png)</code>的方式引用图片，而不需要使用<code>&#123;% asset_img image.png %&#125;</code>的方式引用图片。</p><p>安装<a href="https://github.com/hexojs/hexo-renderer-marked">hexo-render-marked</a>后，在全局<code>_config.yml</code>文件中添加如下配置，当然此处需要保持<code>post_asset_folder: true</code>，否则无法解析图片引用。其解析原理可参考官方仓库Readme中的说明。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">marked:</span><br>  <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><a href="https://github.com/hexojs/hexo-renderer-marked">hexo-render-marked</a>默认只能解析<code>![image](image.png)</code>的方式引用图片，如果想要支持<code>![image](folder/image.png)</code>的方式引用图片，可参考<a href="https://github.com/hexojs/hexo-renderer-marked/issues/216">issue</a>，在<code>node_modules -&gt; hexo-render-marked -&gt; lib -&gt; render.js</code>文件中修改代码即可。</p><p><img src="/hexo-starter/image-3.png" alt="改动部分"></p><p>在VScode中编写markdown文件，如果直接粘贴图片，则默认图片会保存到当前markdown文件的同级目录下，而我们想要效果是图片保存到与文件名同名的目录下，此时可以修改VScode的设置项<code>markdown.copyFiles.destination</code>，可以自定义不同的markdown文件的图片保存目录。</p><p><img src="/hexo-starter/image-4.png" alt="设置图片的保存路径"></p><p>比如此处做如下设置，则图片会保存到与markdown文件同名的目录下。<code>*</code>代表通配符，即当前设置适用于所有markdown文件，详情可参考<a href="https://www.jianshu.com/p/76802b97152e">VSCode 中自定义 Markdown 插入图片的保存路径</a>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;markdown.copyFiles.destination&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;*&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;documentBaseName&#125;/&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="网站部署"><a href="#网站部署" class="headerlink" title="网站部署"></a>网站部署</h3><p>在<code>_config.yml</code>文件中设置<code>deploy</code>字段，可将网站部署到GitHub Pages，也可以部署到其他平台，比如Coding Pages，Netlify等。此处以GitHub Pages为例，首先需要在GitHub上新建一个仓库，仓库名为<code>&lt;username&gt;.github.io</code>，其中<code>&lt;username&gt;</code>为GitHub用户名，然后在<code>_config.yml</code>文件中添加如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <br>    <span class="hljs-attr">github:</span> <span class="hljs-string">&lt;username&gt;/&lt;username&gt;.github.io</span><br>    <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p>然后执行<code>hexo clean</code>命令清除缓存，执行<code>hexo deploy</code>命令部署网站，即可将网站部署到GitHub Pages上。</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端防抖与节流</title>
    <link href="/front/debounce-stream-js/"/>
    <url>/front/debounce-stream-js/</url>
    
    <content type="html"><![CDATA[<p>前端防抖与节流</p><span id="more"></span><p>前端防抖与节流的实现</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>防抖与节流的应用场景，以及如何选择，以及如何实现，以及如何优化，以及如何测试，以及如何调试。所谓防抖是指：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。所谓节流是指：规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。所谓节流是指：规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。</p><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, wait</span>) &#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">let</span> args = <span class="hljs-variable language_">arguments</span>;<br>        <span class="hljs-keyword">if</span> (timer) &#123;<br>            <span class="hljs-built_in">clearTimeout</span>(timer);<br>            timer = <span class="hljs-literal">null</span>;<br>        &#125;<br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            fn.<span class="hljs-title function_">apply</span>(context, args);<br>        &#125;, wait);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, wait</span>) &#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">let</span> args = <span class="hljs-variable language_">arguments</span>;<br>        <span class="hljs-keyword">if</span> (!timer) &#123;<br>            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>                fn.<span class="hljs-title function_">apply</span>(context, args);<br>                timer = <span class="hljs-literal">null</span>;<br>            &#125;, wait);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>防抖</tag>
      
      <tag>节流</tag>
      
      <tag>debounce</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
